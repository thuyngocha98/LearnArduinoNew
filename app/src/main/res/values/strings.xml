<resources>
    <string name="app_name">Learn Arduino</string>
    <string name="facebook_application_id" translatable="false">244861306465677</string>
    <string name="facebook_login_protocol_scheme" translatable="false">fb244861306465677</string>
    <!-- Twitter consumer key and secret -->
    <string name="twitter_consumer_key" translatable="false">N8faeQY6tE6sQ42aYp7Drvkjt</string>
    <string name="twitter_consumer_secret" translatable="false">IZZY3BXvKCdiebzoOzdVOaSY9sOu1Lqad4BABdezM1xByDbdGi</string>

    <string name="navigation_drawer_open">Open navigation drawer</string>
    <string name="navigation_drawer_close">Close navigation drawer</string>
    <string name="nav_header_title">Android Studio</string>
    <string name="nav_header_subtitle">android.studio@android.com</string>
    <string name="nav_header_desc">Navigation header</string>
    <string name="action_settings">Settings</string>
    <string name="basic">Basic</string>
    <string name="sensors">Sensors</string>
    <string name="led">LED</string>
    <string name="movement">Movement</string>
    <string name="introduction_to_arduino">Introduction to \nArduino</string>
    <string name="basic_2">Basic 2</string>
    <string name="questions">questions</string>
    <string name="basic_3">Basic 3</string>
    <string name="basic_4">Basic 4</string>
    <string name="title_activity_sensor1">Sensor1Activity</string>
    <string name="title_activity_sensor2">Sensor2Activity</string>
    <string name="title_activity_sensor3">Sensor3Activity</string>
    <string name="title_activity_sensor4">Sensor4Activity</string>
    <string name="title_activity_sensor5">Sensor5Activity</string>
    <string name="title_activity_sensor6">Sensor6Activity</string>
    <string name="title_activity_sensor7">Sensor7Activity</string>
    <string name="title_activity_sensor8">Sensor8Activity</string>
    <string name="title_activity_sensor9">Sensor9Activity</string>
    <string name="title_activity_sensor10">Sensor10Activity</string>
    <string name="title_activity_sensor11">Sensor11Activity</string>
    <string name="title_activity_sensor12">Sensor12Activity</string>
    <string name="title_activity_sensor13">Sensor13Activity</string>
    <string name="title_activity_sensor14">Sensor14Activity</string>
    <string name="title_activity_sensor15">Sensor15Activity</string>
    <string name="title_activity_sensor16">Sensor16Activity</string>
    <string name="title_activity_sensor17">Sensor17Activity</string>
    <string name="title_activity_sensor18">Sensor18Activity</string>
    <string name="title_activity_sensor19">Sensor19Activity</string>
    <string name="title_activity_sensor20">Sensor20Activity</string>
    <string name="title_activity_sensor21">Sensor21Activity</string>
    <string name="title_activity_sensor22">Sensor22Activity</string>
    <string name="title_activity_sensor23">Sensor23Activity</string>
    <string name="title_activity_sensor24">Sensor24Activity</string>
    <string name="title_activity_sensor25">Sensor25Activity</string>
    <string name="title_activity_sensor26">Sensor26Activity</string>
    <string name="title_activity_sensor27">Sensor27Activity</string>
    <string name="title_activity_sensor28">Sensor28Activity</string>
    <string name="title_activity_sensor29">Tilt Switch</string>
    <string name="title_activity_sensor30">Digital Temperature Sensor</string>
    <string name="title_activity_sensor31">Rainbow LED</string>
    <string name="title_activity_sensor32">Infrared Receiver</string>
    <string name="title_activity_sensor33">Dual-color LED</string>
    <string name="title_activity_sensor34">Sound Sensor</string>
    <string name="title_activity_sensor35">Rotary Encoder</string>
    <string name="title_activity_sensor36">Laser Transmitter</string>
    <string name="title_activity_sensor37">IR Tracking Sensor</string>
    <string name="title_activity_sensor38">Color Detection</string>
    <string name="title_activity_sensor39">Analog-Digital Converter</string>
    <string name="sensor_text_1">Ultrasonic Sensor</string>
    <string name="sensor_text_2">IR Obstacle Avoidance Sensor</string>
    <string name="sensor_text_3">Soil Moisture Sensor</string>
    <string name="sensor_text_4">Microphone Sensor</string>
    <string name="sensor_text_5">Barometric Pressure Sensor</string>
    <string name="sensor_text_6">Photoresistor Sensor</string>
    <string name="sensor_text_7">Temperature Sensor</string>
    <string name="sensor_text_8">Switch Hall Sensor</string>
    <string name="sensor_text_9">Gas Sensor</string>
    <string name="sensor_text_10">Vibration Sensor</string>
    <string name="sensor_text_11">Humidity and Rain Detection Sensor</string>
    <string name="sensor_text_12">Passive Buzzer Module</string>
    <string name="sensor_text_13">Speed Sensor</string>
    <string name="sensor_text_14">IR Flame Detection Sensor</string>
    <string name="sensor_text_15">Relay Module</string>
    <string name="sensor_text_16">PIR Sensor</string>
    <string name="sensor_text_17">Accelerometer Module</string>
    <string name="sensor_text_18">Temperature and Humidity Sensor</string>
    <string name="sensor_text_19">RF Transmitter/Receiver</string>
    <string name="sensor_text_20">Analog Hall Sensor</string>
    <string name="sensor_text_21">Joystick Shield</string>
    <string name="sensor_text_22">Thermometer Detection by thermistor</string>
    <string name="sensor_text_23">Auto flash Led</string>
    <string name="sensor_text_24">Barometer</string>
    <string name="sensor_text_25">Real Time clock</string>
    <string name="sensor_text_26">Touch Sensor</string>
    <string name="sensor_text_27">Photo interrupter</string>
    <string name="sensor_text_28">Reed sensor</string>
    <string name="sensor_text_29">tilt Sensor</string>
    <string name="sensor_text_30">Digital Temperature </string>
    <string name="code_1"><![CDATA[    #define trigPin 11\n   #define echoPin 12\n   #define led 13\n   #define led2 10\n     void setup()\n {\n      Serial.begin (9600);\n     pinMode(trigPin, OUTPUT);\n      pinMode(echoPin, INPUT);\n      pinMode(led, OUTPUT);\n      pinMode(led2, OUTPUT);\n   }\n     void loop() {\n      long duration, distance;\n      digitalWrite(trigPin, LOW);\n     delayMicroseconds(2);\n      digitalWrite(trigPin, HIGH);\n      delayMicroseconds(10);\n      digitalWrite(trigPin, LOW);\n      duration = pulseIn(echoPin, HIGH);\n      distance = (duration/2) / 29.1;\n     if (distance < 4) {\n      digitalWrite(led,HIGH);\n    digitalWrite(led2,LOW);\n   }\n   else {\n   digitalWrite(led,LOW);\n   digitalWrite(led2,HIGH);\n   }\n   if (distance >= 200 || distance <= 0){\n   Serial.println(\"Out of range\");\n   }\n   else {\n   Serial.print(distance);\n   Serial.println(\" cm\");\n   }\n   delay(500);\n   }\n]]></string>
    <string name="code_2">const int ledPin = 13; //pin13 built-in led\n const int avoidPin = 7; //the ir obstacle sensor attach to pin 7\n void setup() {\n  pinMode(ledPin, OUTPUT); //set the ledPin as OUTPUT\n  pinMode(avoidPin, INPUT); //set the avoidPin as INPUT\n }\n void loop() {\n  boolean avoidVal = digitalRead(avoidPin); //read the value of pin7\n   if(avoidVal == LOW)  {\n  digitalWrite(ledPin, HIGH);\n  }else  {\n  digitalWrite(ledPin, LOW);\n   }\n }</string>
    <string name="code_3"> int sensor_pin = A0;\nint output_value ;\n\nvoid setup() {\n   Serial.begin(9600);\n   Serial.println(\"Reading From the Sensor ...\");\n   delay(2000);\n   }\n\nvoid loop() {\n   output_value= analogRead(sensor_pin);\n   output_value = map(output_value,550,0,0,100);\n   Serial.print(\"Mositure : \");\n   Serial.print(output_value);\n   Serial.println(\"%\");\n   delay(1000);\n\n   }</string>
    <string name="code_4">int soundSensor = 2;\n int LED = 3;\n  void setup()  {\n   pinMode (soundSensor, INPUT);\n  pinMode (LED, OUTPUT);\n }\n  void loop() {\n  int statusSensor = digitalRead (soundSensor);\n    if (statusSensor == 1)  {\n  digitalWrite(LED, HIGH);\n  }\n    else  {\n  digitalWrite(LED, LOW);\n  }\n  }</string>
    <string name="code_5"><![CDATA[#include <Wire.h>\n  #include <Adafruit_BMP085.h>\n    // Connect VCC of the BMP180 sensor to 3.3V\n  // Connect GND to Ground\n  // Connect SCL to i2c clock thats A5\n  // Connect SDA to i2c data thats A4\n    Adafruit_BMP085 bmp;\n    void setup()  {\n   Serial.begin(9600);\n   if (!bmp.begin())   {\n   Serial.println(\"BMP180 sensor not found\");\n   while (1) {}   }  }\n    void loop() {\n   Serial.print(\"Temperature = \");\n   Serial.print(bmp.readTemperature());\n   Serial.println(\" *C\");\n     Serial.print(\"Altitude = \");\n   Serial.print(bmp.readAltitude(101500));\n   Serial.println(\" meters\");\n     Serial.println();\n   delay(1000);\n   }]]></string>
    <string name="code_12">int buzzPin = 3; //Connect Buzzer on Digital Pin3\n void setup() {\n pinMode(buzzPin, OUTPUT);\n }\n void loop() {\n digitalWrite(buzzPin, HIGH);\n delay(1);\n digitalWrite(buzzPin, LOW);\n delay(1);\n }\n</string>
    <string name="code_11">int nRainIn = A1;\n int nRainDigitalIn = 2;\n int nRainVal;\n boolean bIsRaining = false;\n String strRaining;\n void setup() {\n Serial.begin(9600);\n pinMode(2,INPUT);\n }\n void loop() {\n nRainVal = analogRead(nRainIn);\n bIsRaining = !(digitalRead(nRainDigitalIn));\n if(bIsRaining){\n strRaining = \"YES\";\n }\n else{\n strRaining = \"NO\";\n }\n Serial.print(\"Raining?: \");\n Serial.print(strRaining);\n Serial.print(\"\t Moisture Level: \");\n Serial.println(nRainVal);\n delay(200);\n }\n</string>
    <string name="code_10"><![CDATA[int LED_Pin = 13;\n int vibr_Pin =3;\n void setup(){\n pinMode(LED_Pin, OUTPUT);\n pinMode(vibr_Pin, INPUT);\n //set vibr_Pin input for measurment\n Serial.begin(9600);\n //init serial 9600 //\n Serial.println(\"----------------------Vibration demo------------------------\");\n }\n void loop(){\n long measurement =TP_init();\n delay(50);\n  Serial.print(\"measurment = \");\n Serial.println(measurement);\n if (measurement > 1000){\n digitalWrite(LED_Pin, HIGH);\n }\n else{\n digitalWrite(LED_Pin, LOW);\n }\n }\n long TP_init(){\n delay(10);\n long measurement=pulseIn (vibr_Pin, HIGH);\n //wait for the pin to get HIGH and returns measurement return measurement;\n }\n]]></string>
    <string name="code_6">int sensorPin = A0; // select the input pin for LDR\n int sensorValue = 0; // variable to store the value coming from the sensor\n void setup() {\n Serial.begin(9600); \n }\n void loop() {\n sensorValue = analogRead(sensorPin);\n // read the value from the sensor\n Serial.println(sensorValue); //prints the values coming from the sensor on the screen\n delay(100);\n }</string>
    <string name="code_7"><![CDATA[#include <math.h>\n int sensorPin = A5; // select the input pin for the potentiometer\n double Thermistor(int RawADC) {\n double Temp;\n Temp = log(10000.0*((1024.0/RawADC-1)));\n Temp = 1 / (0.001129148 + (0.000234125 + (0.0000000876741 * Temp * Temp ))* Temp );\n Temp = Temp - 273.15;\n // Convert Kelvin to Celsius //\nTemp = (Temp * 9.0)/ 5.0 + 32.0;\n // Convert Celsius to Fahrenheit\n return Temp; \n}\n void setup() {\n Serial.begin(9600);\n }\n void loop() {\n int readVal=analogRead(sensorPin);\n double temp = Thermistor(readVal);\n Serial.println(temp);\n // display tempature //\nSerial.println(readVal);\n // display tempature \ndelay(500);\n }]]></string>
    <string name="code_9"><![CDATA[int redLed = 12;\n  int greenLed = 11;\n int buzzer = 10;\n int smokeA0 = A5;\n // Your threshold value \nint sensorThres = 400;\n void setup() {\n pinMode(redLed, OUTPUT);\n pinMode(greenLed, OUTPUT);\n pinMode(buzzer, OUTPUT);\n pinMode(smokeA0, INPUT);\n Serial.begin(9600);\n }\n void loop() {\n int analogSensor = analogRead(smokeA0);\n Serial.print(\"Pin A0: \");\n Serial.println(analogSensor);\n // Checks if it has reached the threshold value\n if (analogSensor > sensorThres) {\n digitalWrite(redLed, HIGH);\n digitalWrite(greenLed, LOW);\n tone(buzzer, 1000, 200);\n }\n else {\n digitalWrite(redLed, LOW);\n digitalWrite(greenLed, HIGH);\n noTone(buzzer);\n } delay(100); }]]></string>
    <string name="code_21"> const int SW_pin = 2;\n // digital pin connected to switch output\n const int X_pin = 0; // analog pin connected to X output\n const int Y_pin = 1; // analog pin connected to Y output\n void setup() {\n pinMode(SW_pin, INPUT);\n digitalWrite(SW_pin, HIGH);\n Serial.begin(115200);\n }\n void loop() {\n Serial.print(\"Switch: \");\n Serial.print(digitalRead(SW_pin));\n Serial.print(\" \");\n Serial.print(\"X-axis: \");\n Serial.print(analogRead(X_pin));\n Serial.print(\" \");\n Serial.print(\"Y-axis: \");\n Serial.println(analogRead(Y_pin));\n Serial.print(\"  \");\n delay(500);\n }</string>
    <string name="code_19_1"><![CDATA[#define datain A0\n #define ledPin 12\n unsigned int temp = 0;\n const unsigned int upperThreshold = 600;\n const unsigned int lowerThreshold = 50;\n void setup() {\n pinMode(ledPin, OUTPUT);\n }\n void loop(){\n temp=analogRead(datain);\n if(temp<lowerThreshold) {\n digitalWrite(ledPin, HIGH);\n } else if(temp>upperThreshold) {\n digitalWrite(ledPin, LOW);\n }\n }\n]]></string>
    <string name="code_19_2">#define dataout 12\n #define ledPin 7\n void setup() {\n pinMode(dataout, OUTPUT);\n pinMode(ledPin, OUTPUT);\n }\n void loop() {\n digitalWrite(dataout, HIGH);\n digitalWrite(ledPin, HIGH);\n delay(2000);\n digitalWrite(dataout,LOW);\n digitalWrite(ledPin, LOW);\n delay(2000);\n }</string>
    <string name="code_18"><![CDATA[#include <dht.h>\n dht DHT;\n #define DHT11_PIN 7\n void setup(){\n Serial.begin(9600);\n }\n void loop() {\n int chk = DHT.read11(DHT11_PIN);\n Serial.print(\"Temperature = \");\n Serial.println(DHT.temperature);\n Serial.print(\"Humidity = \");\n Serial.println(DHT.humidity);\n delay(1000);\n }]]></string>
    <string name="code_17"><![CDATA[#include <Wire.h>\n #include <MPU6050.h>\n MPU6050 accelerometer;\n void setup() {\n Serial.begin(115200);\n Serial.println(\"Initializing the MPU6050 sensor. Wait for a while\");\n delay(2000);\n while(!accelerometer.begin(MPU6050_SCALE_2000DPS, MPU6050_RANGE_2G)) {\n Serial.println(\"Failed to read from the sensor. Something is Wrong!\");\n delay(500);\n }\n }\n void loop() {\n Vector sensor_data = accelerometer.readNormalizeAccel();\n int pitch_value = -(atan2(sensor_data.XAxis, sqrt(sensor_data.YAxis*sensor_data.YAxis + sensor_data.ZAxis*sensor_data.ZAxis))*180.0)/M_PI;\n Serial.print(\" Pitch = \");\n Serial.print(pitch_value);\n int roll_value = (atan2(sensor_data.YAxis, sensor_data.ZAxis)*180.0)/M_PI;\n Serial.print(\" Roll = \");\n Serial.println(roll_value);\n delay(10);\n }\n]]></string>
    <string name="code_16"><![CDATA[#define pirPin 2\n int calibrationTime = 30;\n long unsigned int lowIn;\n long unsigned int pause = 5000;\n boolean lockLow = true;\n boolean takeLowTime;\n int PIRValue = 0;\n void setup() {\n Serial.begin(9600);\n pinMode(pirPin, INPUT);\n }\n void loop() {\n PIRSensor();\n }\n void PIRSensor() {\n if(digitalRead(pirPin) == HIGH) {\n if(lockLow) {\n PIRValue = 1;\n lockLow = false;\n Serial.println(\"Motion detected.\");\n delay(50);\n }\n takeLowTime = true;\n }\n if(digitalRead(pirPin) == LOW) {\n if(takeLowTime){\nlowIn = millis();\ntakeLowTime = false;\n}\n if(!lockLow && millis() - lowIn > pause) {\n PIRValue = 0;\n lockLow = true;\n Serial.println(\"Motion ended.\");\n delay(50);\n }\n }\n }\n]]></string>
    <string name="code_15">#define RELAY1 7\n #define RELAY2 6\n #define RELAY3 5\n #define RELAY4 4\n void setup() {\n pinMode(RELAY1, OUTPUT);\n pinMode(RELAY2, OUTPUT);\n pinMode(RELAY3, OUTPUT);\n pinMode(RELAY4, OUTPUT);\n }\n void loop() {\n digitalWrite(RELAY1,LOW);\n delay(5000); // Wait for 5 seconds\n digitalWrite(RELAY1,HIGH);\n digitalWrite(RELAY2,LOW);\n delay(5000); // Wait for 5 seconds\n digitalWrite(RELAY2,HIGH);\n digitalWrite(RELAY3,LOW);\n delay(5000); // Wait for 5 seconds\n digitalWrite(RELAY3,HIGH);\n digitalWrite(RELAY4,LOW);\n delay(5000); // Wait for 5 seconds \n digitalWrite(RELAY4,HIGH);\n }</string>
    <string name="code_14">int led_pin = 13 ;\n int flame_sensor_pin = 7 ;\n int flame_pin = HIGH ;\n void setup ( ) {\n pinMode ( led_pin , OUTPUT ) ;\n pinMode ( flame_sensor_pin , INPUT ) ;\n Serial.begin ( 9600 ) ;\n }\n void loop ( ) {\n flame_pin = digitalRead ( flame_sensor_pin ) ;\n if (flame_pin == LOW ) {\n Serial.println ( \" FLAME \" ) ;\n digitalWrite ( led_pin , HIGH ) ;\n }\n else {\n Serial.println ( \" no flame \" ) ;\n digitalWrite ( led_pin , LOW ) \n}\n }</string>
    <string name="code_13"><![CDATA[const int dataIN = 2;\n //IR sensor INPUT unsigned\n long prevmillis;\n // To store time unsigned\n long duration;\n // To store time difference\n unsigned long refresh;\n // To store time for refresh of reading\n int rpm;\n // RPM value \n boolean currentstate;\n // Current state of IR input scan\n boolean prevstate;\n // State of IR sensor in previous scan \n void setup() {\n pinMode(dataIN,INPUT);\n prevmillis = 0;\n prevstate = LOW;\n Serial.begin(9600);\n }\n void loop() {\n   currentstate = digitalRead(dataIN);\n if( prevstate != currentstate) {\n if( currentstate == HIGH ) {\n duration = ( micros() - prevmillis );\n rpm = (60000000/duration);\n prevmillis = micros();\n }\n }\n prevstate = currentstate;\n // LCD Display\n if( ( millis()-refresh ) >= 100 ) {\n Serial.println(rpm);\n }\n }\n]]></string>


    <string name="content_21">The joystick in the picture is nothing but two potentiometers that allow us to messure the movement of the stick in 2-D. Potentiometers are variable resistors and, in a way, they act as sensors providing us with a variable voltage depending on the rotation of the device around its shaft.</string>
    <string name="content_20">The ESP8266 is capable of either hosting an application or offloading all Wi-Fi networking functions from another application processor. Each ESP8266 module comes pre-programmed with an AT command set firmware, meaning, you can simply hook this up to your Arduino device and get about as much WiFi-ability as a WiFi Shield offers</string>
    <string name="content_1">An Ultrasonic sensor is a device that can measure the distance to an object by using sound waves. It measures distance by sending out a sound wave at a specific frequency and listening for that sound wave to bounce back. By recording the elapsed time between the sound wave being generated and the sound wave bouncing back, it is possible to calculate the distance between the sonar sensor and the object.  Distance = Time x Speed of Sound divided by 2</string>
    <string name="content_10">The vibration sensor, which is useful for a variety of different fields, has the ability to detect vibrations in a given area. This can help to alert someone to trouble with a system, and you will even find these types of sensors in use with security systems today. They have quite a few different uses.</string>
    <string name="content_11">A rain sensor or rain switch is a switching device activated by rainfall. There are two main applications for rain sensors. The first is a water conservation device connected to an automatic irrigation system that causes the system to shut down in the event of rainfall. The second is a device used to protect the interior of an automobile from rain and to support the automatic mode of windscreen wipers.</string>
    <string name="content_12">A buzzer or beeper is an audio signaling device, which may be mechanical, electromechanical, or piezoelectric. Typical uses of buzzers and beepers include alarm devices, timers and confirmation of user input such as a mouse click or keystroke.</string>
    <string name="content_13">The major goal is to check the rate of an electric motor. The module can be used in association with a microcontroller for motor speed detection, pulse count, position limit, etc. In principle, any rate meter simply measures the rate at which some event occurs. Usually this is done by counting the events for a given period of time (integration interval) and then simply dividing the number of events by the time to get the rate.</string>
    <string name="content_14">The sensor basically detects IR (Infra Red) light wavelength between 760 nm – 1100 nm (nano meter) that is emitted from fire flame. Most of the flame sensors came with YG1006 sensor which is a high speed and high sensitive NPN silicon photo transistor. It is covered with black epoxy, since the sensor is sensitive to infrared radiation. By using this concept project you can understand how to monitor and alert about fire flame, It is most suitable for fire fighting robot, fire alarm etc..,  Analog output (A0): Real-time output voltage signal on the thermal resistance.  Digital output (D0): When the temperature reaches a certain threshold, the output high and low signal threshold adjustable via potentiometer.</string>
    <string name="content_15">A relay is an electrically operated switch. Many relays use an electromagnet to mechanically operate a switch, but other operating principles are also used, such as solid-state relays. Relays are used where it is necessary to control a circuit by a separate low-power signal, or where several circuits must be controlled by one signal.</string>
    <string name="content_16">A passive infrared sensor (PIR sensor) is an electronic sensor that measures infrared (IR) light radiating from objects in its field of view. They are most often used in PIR-based motion detectors.</string>
    <string name="content_17">An accelerometer is an electromechanical device used to measure acceleration forces. Such forces may be static, like the continuous force of gravity or, as is the case with many mobile devices, dynamic to sense movement or vibrations. Acceleration is the measurement of the change in velocity, or speed divided by time.</string>
    <string name="content_18">digital temperature and humidity sensor is a composite Sensor contains a calibrated digital signal output of the temperature and humidity.</string>
    <string name="content_19">Wireless Transmitter Modules allow your Arduino to wirelessly comunicate with other arduinos, or with radio frequency (RF) controlled devices that operate in the same frequency (433Mhz in this case). They work in pairs, meaning you need both a receiver and a transmitter to comunicate with each other.</string>
    <string name="content_2">An obstacle avoidance sensor mainly consists of an infrared transmitter, an infrared receiver and a potentiometer. According to the reflecting character of an object, if there is no obstacle, the emitted infrared ray will weaken with the distance it spreads and finally disappear. If there is an obstacle, when the infrared ray encounters it, the ray will be reflected back to the infrared receiver. Then the infrared receiver detects this signal and confirms an obstacle in front.</string>
    <string name="content_22">t can play up to 22KHz, 12bit uncompressed audio files of any length. It\'s low cost, available as an easy-to-make kit. It has an onboard DAC, filter and op-amp for high quality output. Audio files are read off of an SD/MMC card, which are available at nearly any store. Volume can be controlled with the onboard thumbwheel potentiometer.</string>
    <string name="content_23">The LiquidCrystal library allows you to control LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. A command is an instruction given to LCD to do a predefined task like initializing it, clearing its screen, setting the cursor position, controlling display etc. The data register stores the data to be displayed on the LCD. The data is the ASCII value of the character to be displayed on the LCD.</string>
    <string name="content__24">The Arduino Motor Shield is based on the L298 (datasheet), which is a dual full-bridge driver designed to drive inductive loads such as relays, solenoids, DC and stepping motors. It lets you drive two DC motors with your Arduino board, controlling the speed and direction of each one independently.</string>
    <string name="content_25">The Arduino Ethernet Shield allows an Arduino board to connect to the internet. It is based on the Wiznet W5100 ethernet chip (datasheet). The Wiznet W5100 provides a network (IP) stack capable of both TCP and UDP. It supports up to four simultaneous socket connections. Use the Ethernet library to write sketches which connect to the internet using the shield. The ethernet shield connects to an Arduino board using long wire-wrap headers which extend through the shield. This keeps the pin layout intact and allows another shield to be stacked on top</string>
    <string name="content_26">Among other things, GSM supports outgoing and incoming voice calls, Simple Message System (SMS or text messaging), and data communication (via GPRS). The Arduino GSM shield is a a GSM modem. From the mobile operator perspective, the Arduino GSM shield looks just like a mobile phone.</string>
    <string name="content_27">The microSD Shield equips your Arduino with mass-storage capability, so you can use it for data-logging or other related projects. Communication with microSD cards is achieved over an SPI interface.</string>
    <string name="content_3">The Soil Moisture Sensor uses capacitance to measure the water content of soil (by measuring the dielectric permittivity of the soil, which is a function of the water content). Simply insert this rugged sensor into the soil to be tested, and the volumetric water content of the soil is reported in percent.</string>
    <string name="content_4">A microphone is an acoustic to electric transducer or sensor that detects sound signals and converts them into an electrical signal.  Most of the microphones employ light modulation, piezoelectric generation, capacitance change and electromagnetic induction to produce an electrical voltage signal from mechanical vibration.\n For sound detection Module has two outputs:\nAO, analog output, real-time output voltage signal of the microphone\nDO, when the sound intensity reaches a certain threshold, the output high and low signal\nThe threshold-sensitivity can be adjusted via potentiometer on the sensor</string>
    <string name="content_5">Barometric pressure sensor detects the atmospheric pressure. This sensor is used for indoor navigation, elevator/floor change detection and weather monitoring.</string>
    <string name="content_6">Photosensitive resistor module most sensitive to environmental light intensity is generally used to detect the ambient brightness and light intensity.</string>
    <string name="content_7">A temperature sensor is a device, typically, a thermocouple or RTD, that provides for temperature measurement through an electrical signal. A thermocouple (T/C) is made from two dissimilar metals that generate electrical voltage in direct proportion to changes in temperature.</string>
    <string name="content_9">A gas detector is a device that detects the presence of gases in an area, often as part of a safety system. This type of equipment is used to detect a gas leak or other emissions and can interface with a control system so a process can be automatically shut down.</string>


    <string name="code_20">const int ledPin = 13;\nint sensorPin = A0;\nint digitalPin=7;\nint sensorValue = 0;\nboolean digitalValue=0;\nvoid setup()\n{\n  pinMode(digitalPin,INPUT);\n  pinMode(ledPin,OUTPUT);\n  Serial.begin(9600);\n}\nvoid loop()\n{\n  sensorValue = analogRead(sensorPin);\n  digitalValue=digitalRead(digitalPin);\n  Serial.print("Sensor Value ");\n  Serial.println(sensorValue);\n  Serial.print("Digital Value ");\n  Serial.println(digitalValue);\n  if( digitalValue==HIGH )\n  {\n    digitalWrite(ledPin,LOW);\n  }\n  if( digitalValue==LOW)\n  {\n    digitalWrite(ledPin,HIGH);\n  }\n  delay(1000);//delay 200ms\n}</string>
    <string name="code_8">const int hallPin = 8;\nconst int ledPin = 13;\nconst int buzzerPin=7;\nint val = 0;\nvoid setup()\n{\n  pinMode(hallPin,INPUT);\n  pinMode(ledPin,OUTPUT);\n  pinMode(buzzerPin,OUTPUT);\n  Serial.begin(9600);\n}\nvoid loop()\n{\n  val = digitalRead(hallPin);\n  Serial.println(val);\n  if(val == HIGH)\n  {\n    digitalWrite(ledPin,LOW);\n    noTone(7);\n  }\n  if(val == LOW)\n  {\n    digitalWrite(ledPin,HIGH);\n   tone(7,320,200);\n  }\n  delay(500);//to get a beeping tone\n}</string>
    <string name="code_22">#include &lt;Wire.h&gt;\n#include &lt;LiquidCrystal_I2C.h&gt;\nLiquidCrystal_I2C lcd(0x27,16,2);\n#define analogPin A0\n#define beta 3950\n#define resistance 10\nvoid setup()\n{\n  lcd.init();\n  lcd.backlight();\n  Serial.begin(9600);\n}\nvoid loop()\n{\n  long a =1023 - analogRead(analogPin);\n  Serial.print("Raw reading ");\n  Serial.println(a);\n  float tempC = beta /(log((1025.0 * 10 / a - 10) / 10) + beta / 298.0) - 273.0;\n  float tempF = 1.8*tempC + 32.0;\n  Serial.print("Centigrade ");\n  Serial.println(tempC);\n  Serial.print("Fahrenheit ");\n  Serial.println(tempF);\n  Serial.println("");\n  lcd.setCursor(0, 0);\n  lcd.print("Temp: ");\n  lcd.print(tempC);\n  lcd.write(char(223));\n  lcd.print("C");\n  lcd.setCursor(0, 1);\n  lcd.print("Fahr: ");\n  lcd.print(tempF);\n  lcd.write(char(223));\n  lcd.print(" F");F"\n  delay(200);\n}
 </string>
    <string name="code_23"></string>
    <string name="code_24"></string>
    <string name="code_25"></string>
    <string name="code_26">const int SensorPin=7;\nconst int ledPin = 13;\nint SensorState=0;\nvoid setup()\n{\n  pinMode(SensorPin,INPUT);\n  pinMode(ledPin,OUTPUT);\n  Serial.begin(9600);\n}\nvoid loop()\n{\n  SensorState=digitalRead(SensorPin);\n  Serial.println( SensorState);\n  if(SensorState==HIGH)\n  {\n    digitalWrite(ledPin,LOW);\n  }\n  else\n  {\n    digitalWrite(ledPin,HIGH); /\n  }\n}</string>
    <string name="code_27">const int photoPin = 7;\nconst int ledPin = 13;\nvoid setup()\n{\n  pinMode(photoPin,INPUT);\n  pinMode(ledPin,OUTPUT);\n}\nvoid loop()\n{\n  boolean Value=digitalRead(photoPin);\n  if(Value ==HIGH )\n  {\n    digitalWrite(ledPin,LOW);\n  }\n  else\n  {\n    digitalWrite(ledPin,HIGH);\n  }\n}</string>
    <string name="code_28">const int digitalInPin = 7;
\nconst int ledPin = 13;
\nvoid setup()
\n{
\n  pinMode(digitalInPin,INPUT);
\n  pinMode(ledPin,OUTPUT);
\n}
\nvoid loop()
\n{
\n  boolean stat = digitalRead(digitalInPin);
\n  if(stat == HIGH)
\n  {
\n    digitalWrite(ledPin,LOW);
\n  }
\n  else //else
\n  {
\n    digitalWrite(ledPin,HIGH);
\n  }
\n}</string>
    <string name="code_29">const int sigPin = 7;
\nconst int ledPin = 13;
\nboolean sigState = 0;
\nvoid setup()
\n{
\n  pinMode(ledPin, OUTPUT);
\n  pinMode(sigPin, INPUT);
\n}
\nvoid loop()
\n{
\n  sigState = digitalRead(sigPin);
\n  if (sigState == HIGH)
\n  {
\n    digitalWrite(ledPin, LOW);
\n  }
\n  else
\n  {
\n    digitalWrite(ledPin, HIGH);
\n  }
\n}</string>
    <string name="code_30">#include &lt;OneWire.h&gt;
\n#include &lt;DallasTemperature.h&gt;
\n#include &lt;LiquidCrystal_I2C.h&gt;
\n#include &lt;Wire.h&gt;
\nLiquidCrystal_I2C lcd(0x27,16,2);
\n#define ONE_WIRE_BUS 7
\nOneWire oneWire(ONE_WIRE_BUS);
\nDallasTemperature sensors(&amp;oneWire);
\nvoid setup(void)
\n{
\n  Serial.begin(9600);
\n  sensors.begin();
\n  lcd.init();
\n  lcd.backlight();
\n}
\nvoid loop(void)
\n{
\n
\n  sensors.requestTemperatures();
\n  lcd.setCursor(0, 0);
\n  lcd.print("TemC: ");
\n  lcd.print(sensors.getTempCByIndex(0));
\n
\n  lcd.print(char(223));
\n  lcd.print("C");
\n  lcd.setCursor(0, 1);
\n  lcd.print("TemF: ");
\n  lcd.print(1.8*sensors.getTempCByIndex(0) + 32.0);/
\n  lcd.print(char(223));
\n  lcd.print(" F");
\n
\n}</string>
    <string name="code_31">const int redPin = 11;\nconst int greenPin = 10;\nconst int bluePin = 9;\n\n        void setup()\n{\n  pinMode(redPin, OUTPUT);\n  pinMode(greenPin, OUTPUT);\n  pinMode(bluePin, OUTPUT);\n}\nvoid loop()\n{\n\n  color(255, 0, 0);\n  delay(1000);\n  color(0,255, 0);\n  delay(1000);\n  color(0, 0, 255);\n  delay(1000);\n\n  color(255,0,0);\n  delay(1000);\n  color(237,109,0);\n  delay(1000);\n  color(255,215,0);\n  delay(1000);\n  color(0,255,0);\n  delay(1000);\n  color(0,0,255);\n  delay(1000);\n  color(0,46,90);\n  delay(1000);\n  color(128,0,128);\n  delay(1000);\n}\nvoid color (unsigned char red, unsigned char green, unsigned char blue)\n{\n  analogWrite(redPin, red);\n  analogWrite(bluePin, blue);\n  analogWrite(greenPin, green);\n}</string>
    <string name="code_32">#include &lt;IRremote.h&gt;\nconst int irReceiverPin =7;\nconst int ledPin = 13;\nIRrecv irrecv(irReceiverPin);\ndecode_results results;\nvoid setup()\n{\n  pinMode(ledPin,OUTPUT);\n  Serial.begin(9600);\n  irrecv.enableIRIn();\n}\nvoid loop()\n{\n  if (irrecv.decode(&amp;results))\n  {\n    Serial.print("irCode: ");\n    Serial.print(results.value, HEX);\n    Serial.print(", bits: ");\n    Serial.println(results.bits);\n    irrecv.resume();\n  }\n  delay(600);\n  if(results.value == 0xE318261B)\n  {\n    digitalWrite(ledPin,HIGH);\n  }\n  else\n  {\n    digitalWrite(ledPin,LOW);\n  }\n}\n </string>
    <string name="code_33">int redPin = 11;\nint greenPin = 10;\nint val = 0;\nvoid setup()\n{\n  pinMode(redPin, OUTPUT);\n  pinMode(greenPin, OUTPUT);\n  Serial.begin(9600);\n}\n\nvoid loop()\n{\n  for(val=255; val>0; val	&#150;	&#150;)\n  {\n    analogWrite(redPin, val);\n    analogWrite(greenPin, 255-val);\n    Serial.println(val, DEC);\n    delay(30); //delay 30ms\n  }\n  for(val=0; val &lt; 255; val++)\n  {\n    analogWrite(redPin, val);\n    analogWrite(greenPin, 255-val);\n    Serial.println(val, DEC);\n    delay(30);\n  }\n}</string>
    <string name="code_34">const int ledPin = 13;\nconst int soundPin = A0;\nvoid setup()\n{\n  pinMode(ledPin,OUTPUT);\n  Serial.begin(9600);\n}\nvoid loop()\n{\n  int value = analogRead(soundPin);\n  Serial.println(value);\n  if(value > 600)\n  {\n    digitalWrite(ledPin,HIGH);\n    delay(200);//delay 200ms\n  }\n  else\n  {\n    digitalWrite(ledPin,LOW);\n  }\n}\n</string>
    <string name="code_35">const int clkPin= 2;\nconst int dtPin= 3;\nconst int swPin= 4 ;\nint encoderVal = 0;\nvoid setup()\n{\n\n  pinMode(clkPin, INPUT);\n  pinMode(dtPin, INPUT);\n  pinMode(swPin, INPUT);\n  digitalWrite(swPin, HIGH);\n  Serial.begin(9600);\n}\nvoid loop()\n{\n  int change = getEncoderTurn();\n  encoderVal = encoderVal &#8211; change;\n  if(digitalRead(swPin) == LOW)\n  {\n    encoderVal = 0;\n  }\n  Serial.println(encoderVal);\n}\nint getEncoderTurn(void)\n{\n  static int oldA = HIGH;\n  static int oldB = HIGH;\n  int result = 0;\n  int newA = digitalRead(clkPin);\n  int newB = digitalRead(dtPin);\n  if (newA != oldA || newB != oldB)\n  {\n\n    if (oldA == HIGH &amp;&amp; newA == LOW)\n    {\n      result = (oldB * 2 &#8211; 1);\n    }\n  }\n  oldA = newA;\n  oldB = newB;\n  return result;\n}</string>
    <string name="code_36"></string>
    <string name="code_37">const int trackingPin = 7;\nconst int ledPin = 13;\nvoid setup()\n{\n  pinMode(trackingPin, INPUT);\n  pinMode(ledPin, OUTPUT);\n}\nvoid loop()\n{\n  boolean val = digitalRead(trackingPin);\n  if(val == HIGH)\n  {\n    digitalWrite(ledPin, LOW);\n  }\n  else\n  {\n    digitalWrite(ledPin, HIGH); /\n  }\n}</string>
    <string name="code_38">#include &lt;TimerOne.h&gt;\n#define S0 3\n#define S1 4\n#define S2 5\n#define S3 6\n#define OUT 2\nint g_count = 0;\nint g_array[3];\nint g_flag = 0;\nfloat g_SF[3];\n\nvoid TSC_Init()\n{\n  pinMode(S0, OUTPUT);\n  pinMode(S1, OUTPUT);\n  pinMode(S2, OUTPUT);\n  pinMode(S3, OUTPUT);\n  pinMode(OUT, INPUT);\n\n  digitalWrite(S0, LOW);\n  digitalWrite(S1, HIGH);\n}\nvoid TSC_FilterColor(int Level01, int Level02)\n{\n  if(Level01 != 0)\n    Level01 = HIGH\n\n  if(Level02 != 0)\n    Level02 = HIGH;\n\n  digitalWrite(S2, Level01);\n  digitalWrite(S3, Level02);\n}\nvoid TSC_Count()\n{\n  g_count ++ ;\n}\nvoid TSC_Callback()\n{\n  switch(g_flag)\n  {\n    case 0:\n      Serial.println("->WB Start");\n      TSC_WB(LOW, LOW);\n      break;\n    case 1:\n      Serial.print("->Frequency R=");\n      Serial.println(g_count);\n      g_array[0] = g_count;\n      TSC_WB(HIGH, HIGH);\n      break;\n    case 2:\n      Serial.print("->Frequency G=");\n      Serial.println(g_count);\n      g_array[1] = g_count;\n      TSC_WB(LOW, HIGH);\n      break;\n    case 3:\n      Serial.print("->Frequency B=");\n      Serial.println(g_count);\n      Serial.println("->WB End");\n      g_array[2] = g_count;\n      TSC_WB(HIGH, LOW);\n      break;\n    default:\n      g_count = 0;\n      break;\n  }\n}\nvoid TSC_WB(int Level0, int Level1)\n{\n  g_count = 0;\n  g_flag ++;\n  TSC_FilterColor(Level0, Level1);\n  Timer1.setPeriod(1000000);\n}\nvoid setup()\n{\n  TSC_Init();\n  Serial.begin(9600);\n  Timer1.initialize();\n  Timer1.attachInterrupt(TSC_Callback);\n  attachInterrupt(0, TSC_Count, RISING);\n  delay(4000);\n  for(int i=0; i&lt;3; i++)\n  Serial.println(g_array[i]);\n  g_SF[0] = 255.0/ g_array[0];\n  g_SF[1] = 255.0/ g_array[1] ;\n  g_SF[2] = 255.0/ g_array[2] ;\n  Serial.println(g_SF[0]);\n  Serial.println(g_SF[1]);\n  Serial.println(g_SF[2]);\n}\nvoid loop()\n{\n  g_flag = 0;\n  for(int i=0; i&lt;3; i++)\n  Serial.println(int(g_array[i] * g_SF[i]));\n  delay(4000);\n}</string>
    <string name="code_39">#include &quot;Wire.h&quot;\n#define PCF8591 (0x90 &gt;&gt; 1)\nvoid setup()\n{\n  Wire.begin();\n  Serial.begin(9600);\n  Serial.println(sin(PI/2));\n}\nvoid loop()\n{\n  for (int i=0; i&lt;256; i++)\n  {\n    Wire.beginTransmission(PCF8591);\n    Wire.write(0x40);\n    Wire.write(i);\n    Wire.endTransmission();\n    delay(10*sin(i/256.0*90/180*PI));\n    Serial.println(100*sin(i/256.0*90/180*PI));\n}\nfor (int i=255; i>=0; &#8212;i)\n{\n    Wire.beginTransmission(PCF8591);\n    Wire.write(0x40);\n    Wire.write(i);\n    Wire.endTransmission();\n    delay(10*sin(i/256.0*90/180*PI));\n    Serial.println(100*sin(i/256.0*90/180*PI));\n  }\n}</string>


    <string name="contents_39"></string>
    <string name="contents_38"></string>
    <string name="contents_37"></string>
    <string name="contents_36"></string>
    <string name="contents_35"></string>
    <string name="contents_34"></string>
    <string name="contents_33"></string>
    <string name="contents_32"></string>
    <string name="contents_31"></string>
    <string name="contents_30"></string>
    <string name="contents_29"></string>
    <string name="contents_28"></string>
    <string name="contents_27"></string>
    <string name="contents_26"></string>
    <string name="contents_25"></string>
    <string name="contents_24"></string>
    <string name="contents_23"></string>
    <string name="contents_22"></string>
    <string name="contents_8"></string>
    <string name="contents_20"></string>
    <string name="title_activity_sensors1">Sensors1</string>
    <string name="title_home">Home</string>
    <string name="title_dashboard">Dashboard</string>
    <string name="title_notifications">Notifications</string>
    <string name="title_activity_sensors2">Sensors2</string>
    <string name="title_activity_sensors3">Sensors3</string>


    <string name="led1_text_view">void setup() {\n pinMode(13, OUTPUT);\n}\nvoid loop() {\n digitalWrite(13, HIGH); \n delay(1000); \n digitalWrite(13, LOW);\n delay(1000); \n}\n</string>
    <string name="led2_text_view">This example demonstrates the use of analog output (Pulse Width Modulation (PWM)) to fade an LED. PWM is a technique for getting an analog-like behavior from a digital output by switching it off and on very fast and with different ratio between on and off time.</string>
    <string name="led2p_text_view"><![CDATA[int ledPin = 9;\nvoid setup() {\n}\n\nvoid loop() {\nfor (int fadeValue = 0 ; fadeValue <= 255; fadeValue += 5) {\nanalogWrite(ledPin, fadeValue);\ndelay(30);\n}\n\n for (int fadeValue = 255 ; fadeValue >= 0; fadeValue -= 5) {\nanalogWrite(ledPin, fadeValue);\ndelay(30);\n }\n}]]></string>
    <string name="led3d_text_view">This example shows you how to read an analog input pin, map the result to a range from 0 to 255, use that result to set the pulse width modulation (PWM) of an output pin to dim or brighten an LED and print the values on the serial monitor of the Arduino Software (IDE).</string>
    <string name="led3p_text_view">const int analogInPin = A0;\nconst int analogOutPin = 9;\nint sensorValue = 0; \nint outputValue = 0; \n\nvoid setup() {\n Serial.begin(9600);\n}\n\nvoid loop() {\n sensorValue = analogRead(analogInPin);\n outputValue = map(sensorValue, 0, 1023, 0, 255);\n analogWrite(analogOutPin, outputValue);\n Serial.print(\" sensor = \");\n Serial.print(sensorValue);\n Serial.print(\"\t output = \");\n Serial.println(outputValue);\n delay(2);\n}</string>
    <string name="led4d_text_view">Pushbuttons or switches connect two points in a circuit when you press them. This example turns on the built-in LED on pin 13 when you press the button.</string>
    <string name="led4p_text_view">const int buttonPin = 2; \nconst int ledPin = 13; \nint buttonState = 0; \n\nvoid setup() { pinMode(ledPin, OUTPUT);\n pinMode(buttonPin, INPUT);\n\nvoid loop() {\n buttonState = digitalRead(buttonPin);\n if (buttonState == HIGH) {\n digitalWrite(ledPin, HIGH);\n } else {\n digitalWrite(ledPin, LOW);\n }\n}\n</string>
    <string name="led5d_text_view">This  example uses the Arduino or Genuino board to receive data from the computer. The board turns on an LED when it receives the character \'H\', and turns off the LED when it receives the character \'L\'.</string>
    <string name="led5p_text_view"><![CDATA[const int ledPin = 13; \nint incomingByte; \n\nvoid setup() { Serial.begin(9600);\n pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n if (Serial.available() > 0) {\n incomingByte = Serial.read();\n if (incomingByte == \'H\') {\n digitalWrite(ledPin, HIGH);\n if (incomingByte == \'L\') {\n digitalWrite(ledPin, LOW);\n }\n }\n}]]></string>
    <string name="led6d_text_view">This sketch will take the analog voltage reading and use that to determine how bright the red LED is. The darker it is, the brighter the LED will be! Remember that the LED has to be connected to a PWM pin for this to work, I use pin 11 in this example.</string>
    <string name="led6p_text_view">int photocellPin = 0; \nint photocellReading;\nint LEDpin = 11; \nint LEDbrightness; \nvoid setup(void) {\n Serial.begin(9600);\n}\n\nvoid loop(void) {\nphotocellReading = analogRead(photocellPin);\n Serial.print(\"Analog reading = \");\nSerial.println(photocellReading); \n photocellReading = 1023 - photocellReading;\n LEDbrightness = map(photocellReading, 0, 1023, 0, 255);\n analogWrite(LEDpin, LEDbrightness);\n delay(100);\n}</string>
    <string name="led8_text_view"><![CDATA[char data = 0;\nvoid setup()\n{\n Serial.begin(9600); \n pinMode(13, OUTPUT);\n}\nvoid loop()\n {\n if(Serial.available() > 0) \n {\n data = Serial.read();\n Serial.print(data);\n Serial.print(\"\n\");\n if(data == \'1\')\n digitalWrite(13, HIGH);\n else if(data == \'0\')\n digitalWrite(13, LOW);\n }\n\n}]]></string>
    <string name="led9_text_view"><![CDATA[#include <IRremote.h>\nint RECV_PIN = 3;\nint led1 = 2;\nint led2 = 4;\nint led3 = 7;\nint itsONled[] = {0,0,0,0};\n#define code1 63495\n#define code2 30855\n#define code3 22695\nIRrecv irrecv(RECV_PIN);\n \ndecode_results results;\n \nvoid setup()\n{\n Serial.begin(9600); // you can comment this line\n irrecv.enableIRIn(); // Start the receiver\n pinMode(led1, OUTPUT);\n pinMode(led2, OUTPUT);\n pinMode(led3, OUTPUT);\n}\n \nvoid loop() {\n if (irrecv.decode(&results)) {\n unsigned int value = results.value;\n switch(value) {\n case code1:\n if(itsONled[1] == 1) { \n digitalWrite(led1, LOW); itsONled[1] = 0;\n } else {\n digitalWrite(led1, HIGH);\n itsONled[1] = 1;\n }\n break; \n case code2:\n if(itsONled[2] == 1) {\n digitalWrite(led2, LOW);\n itsONled[2] = 0;\n } else {\n digitalWrite(led2, HIGH);\n itsONled[2] = 1;\n }\n break;\n case code3:\n if(itsONled[3] == 1) {\n digitalWrite(led3, LOW);\n itsONled[3] = 0;\n } else {\n digitalWrite(led3, HIGH);\n itsONled[3] = 1;\n }\n break; \n }\n Serial.println(value);\n irrecv.resume(); \n }\n}]]></string>
    <string name="led19_text_view"><![CDATA[const int hot = 87; //set hot parameter\nconst int cold = 75; //set cold parameter\nvoid setup() {\npinMode(A2, INPUT); //sensor\npinMode(2, OUTPUT); //blue\npinMode(3, OUTPUT); //green\npinMode(4, OUTPUT); //red\nSerial.begin(9600);\n}\nvoid loop() {\nint sensor = analogRead(A2);\nfloat voltage = (sensor / 1024.0) * 5.0;\nfloat tempC = (voltage - .5) * 100;\nfloat tempF = (tempC * 1.8) + 32;\nSerial.print(\"temp: \");\nSerial.print(tempF);\nif (tempF < cold) { //cold\ndigitalWrite(2, HIGH);\ndigitalWrite(3, LOW);\ndigitalWrite(4, LOW);\nSerial.println(\" It\'s Cold.\");\n}\nelse if (tempF >= hot) { //hot\ndigitalWrite(2, LOW);\ndigitalWrite(3, LOW);\ndigitalWrite(4, HIGH);\nSerial.println(\" It\'s Hot.\");\n}\nelse { //fine\ndigitalWrite(2, LOW);\ndigitalWrite(3, HIGH);\ndigitalWrite(4, LOW);\nSerial.println(\" It\'s Fine.\");\n}\ndelay(10);\n}]]></string>
    <string name="led11_text_view">int pinLeds1 = 10;\nint pinLeds2 = 9;\nint pinLeds3 = 7;\nint pinLed4 = 8;\nint buttonPin = 6;\nint buttonState;\nlong ran;\nint time = 2000;\n\nvoid setup ()\n{\n pinMode (pinLeds1, OUTPUT);\n pinMode (pinLeds2, OUTPUT);\n pinMode (pinLeds3, OUTPUT);\n pinMode (pinLed4, OUTPUT);\n pinMode (buttonPin, INPUT);\n randomSeed(analogRead(0));\n}\n\nvoid loop()\n{\n buttonState = digitalRead(buttonPin);\n if (buttonState == HIGH){\n ran = random(1, 7);\n if (ran == 1){\n digitalWrite (pinLed4, HIGH);\n delay (time);\n }\n if (ran == 2){\n digitalWrite (pinLeds1, HIGH);\n delay (time);\n }\n if (ran == 3){\n digitalWrite (pinLeds3, HIGH);\n digitalWrite (pinLed4, HIGH);\n delay (time);\n }\n if (ran == 4){\n digitalWrite (pinLeds1, HIGH);\n digitalWrite (pinLeds3, HIGH);\n delay (time);\n }\n if (ran == 5){\n digitalWrite (pinLeds1, HIGH);\n digitalWrite (pinLeds3, HIGH);\n digitalWrite (pinLed4, HIGH);\n delay (time);\n }\n if (ran == 6){\n digitalWrite (pinLeds1, HIGH);\n digitalWrite (pinLeds2, HIGH);\n digitalWrite (pinLeds3, HIGH);\n delay (time);\n }\n }\n digitalWrite (pinLeds1, LOW);\n digitalWrite (pinLeds2, LOW);\n digitalWrite (pinLeds3, LOW);\n digitalWrite (pinLed4, LOW);\n}</string>
    <string name="led12_text_view"><![CDATA[int LED1Pin = 1;\n int LED2Pin = 2;\n int LED3Pin = 3;\n int LED4Pin = 4;\nint LED5Pin = 5;\n int LED6Pin = 6;\n int LED7Pin = 7;\n int LED8Pin = 8;\n int spin = 1;\n int prize = 1;\n void setup() {\n pinMode(LED1Pin, OUTPUT);\n pinMode(LED2Pin, OUTPUT);\n pinMode(LED3Pin, OUTPUT);\n pinMode(LED4Pin, OUTPUT);\n pinMode(LED5Pin, OUTPUT);\n pinMode(LED6Pin, OUTPUT);\n pinMode(LED7Pin, OUTPUT);\n pinMode(LED8Pin, OUTPUT);\n pinMode(A0, INPUT);\n pinMode(A1, INPUT);\n digitalWrite(A0, HIGH);\n digitalWrite(A1, HIGH);\n }\nvoid loop() {\n if (prize > 8) prize = 0;\n if (digitalRead(A0) == LOW) spin=1;\n if (digitalRead(A1) == LOW) spin=0;\n if (spin==1) { prize++;\n digitalWrite (LED1Pin, LOW);\n digitalWrite (LED2Pin, LOW);\n digitalWrite (LED3Pin, LOW);\n digitalWrite (LED4Pin, LOW);\ndigitalWrite (LED5Pin, LOW);\n digitalWrite (LED6Pin, LOW);\n digitalWrite (LED7Pin, LOW);\n digitalWrite (LED8Pin, LOW);\n if (prize==1) digitalWrite (LED1Pin, HIGH);\n if (prize==2) digitalWrite (LED2Pin, HIGH);\n if (prize==3) digitalWrite (LED3Pin, HIGH);\n if (prize==4) digitalWrite (LED4Pin, HIGH);\n if (prize==5) digitalWrite (LED5Pin, HIGH);\n if (prize==6) digitalWrite (LED6Pin, HIGH);\n if (prize==7) digitalWrite (LED7Pin, HIGH);\n if (prize==8) digitalWrite (LED8Pin, HIGH);\n }\n delay(50);\n }\n]]></string>
    <string name="led18_text_view"><![CDATA[int LED1Pin = 1;\n int LED2Pin = 2;\n int LED3Pin = 3;\n int LED4Pin = 4;\n int LED5Pin = 5;\nvoid setup() {\n pinMode(LED1Pin, OUTPUT);\n pinMode(LED2Pin, OUTPUT);\n pinMode(LED3Pin, OUTPUT);\n pinMode(LED4Pin, OUTPUT);\n pinMode(LED5Pin, OUTPUT);\n}\n for (int scan = 1; scan < 9; scan++){\n digitalWrite (LED1Pin, LOW);\n digitalWrite (LED2Pin, LOW);\n digitalWrite (LED3Pin, LOW);\n digitalWrite (LED4Pin, LOW);\n digitalWrite (LED5Pin, LOW);\nif (scan ==1) digitalWrite (LED1Pin, HIGH);\n if (scan ==2) digitalWrite (LED2Pin, HIGH);\nif (scan ==3) digitalWrite (LED3Pin, HIGH);\n if (scan ==4) digitalWrite (LED4Pin, HIGH);\n if (scan ==5) digitalWrite (LED5Pin, HIGH);\n if (scan ==6) digitalWrite (LED4Pin, HIGH);\n if (scan ==7) digitalWrite (LED3Pin, HIGH);\n if (scan ==8) digitalWrite (LED2Pin, HIGH);\n delay(500);\n }\n }]]></string>
    <string name="led17_text_view">int ledDelay = 50; // delay by 50ms\nint redPin = 9;\nint bluePin = 11;\n\nvoid setup() {\npinMode(redPin, OUTPUT);\npinMode(bluePin, OUTPUT);\n\n}\n\nvoid loop() {\n\ndigitalWrite(redPin, HIGH); \ndelay(ledDelay); \n\ndigitalWrite(redPin, LOW); \ndelay(ledDelay); \n\ndigitalWrite(redPin, HIGH); \ndelay(ledDelay); \n\ndigitalWrite(redPin, LOW);\ndelay(ledDelay); \n\ndigitalWrite(redPin, HIGH); \ndelay(ledDelay); \n\ndigitalWrite(redPin, LOW); \ndelay(ledDelay); \n\ndelay(100); \n\ndigitalWrite(bluePin, HIGH); \ndelay(ledDelay); \n\ndigitalWrite(bluePin, LOW); \ndelay(ledDelay); \n\ndigitalWrite(bluePin, HIGH); \ndelay(ledDelay); \n\ndigitalWrite(bluePin, LOW); \ndelay(ledDelay); \n\ndigitalWrite(bluePin, HIGH); \ndelay(ledDelay); \n\ndigitalWrite(bluePin, LOW); \ndelay(ledDelay); \n\n}</string>
    <string name="led16_text_view">int led1 = 13;\nint led2 = 12;\nint led3 = 11;\nint led4 = 10;\nint led5 = 9;\nint led6 = 8;\n\nvoid setup() { \npinMode(led1, OUTPUT); \npinMode(led2, OUTPUT); \npinMode(led3, OUTPUT); \npinMode(led4, OUTPUT); \npinMode(led5, OUTPUT); \npinMode(led6, OUTPUT); \n}\n\nvoid loop() {\n digitalWrite(led1, HIGH); \n delay(100); \n digitalWrite(led6, LOW); \n delay(100); \n digitalWrite(led2, HIGH); \n delay(100); \n digitalWrite(led1, LOW); \n delay(100); \n digitalWrite(led3, HIGH); \n delay(100); \n digitalWrite(led2, LOW); \n delay(100); \n digitalWrite(led4, HIGH); \n delay(100); \n digitalWrite(led3, LOW); \n delay(100); \n digitalWrite(led5, HIGH); \n delay(100); \n digitalWrite(led4, LOW); \n delay(100); \n digitalWrite(led6, HIGH); \n delay(100); \n digitalWrite(led5, LOW); \n delay(100); \n digitalWrite(led6, HIGH); \n delay(100); \n \n digitalWrite(led5, HIGH); \n delay(100); \n digitalWrite(led6, LOW); \n delay(100);\n digitalWrite(led4, HIGH); \n delay(100); \n digitalWrite(led5, LOW); \n delay(100);\n digitalWrite(led3, HIGH); \n delay(100); \n digitalWrite(led4, LOW); \n delay(100);\n digitalWrite(led2, HIGH); \n delay(100); \n digitalWrite(led3, LOW); \n delay(100);\n digitalWrite(led2, LOW); \n delay(100);\n }</string>
    <string name="led15_text_view">// Connect green LED to pin 13\n// Connect yellow LED to pin 12\n// Connect red LED to pin 11\n\nvoid setup() { \n \n pinMode(11, OUTPUT);\n pinMode(12, OUTPUT);\n pinMode(13, OUTPUT);\n} \n\nvoid loop(){{\n digitalWrite(13, HIGH); \ndelay(2500); \n digitalWrite(13, LOW);\ndelay(0);}\n digitalWrite(12, HIGH); \ndelay(2500); \n digitalWrite(12, LOW); \ndelay(0);\n digitalWrite(11, HIGH); \ndelay(2500); \n digitalWrite(11, LOW); \ndelay(0);\n}</string>
    <string name="led14"><![CDATA[int pinArray[] = {2, 3, 4, 5, 6, 7};\nint count = 0;\nint timer = 100;\n\nvoid setup(){\n for (count=0;count<6;count++) {\n pinMode(pinArray[count], OUTPUT);\n }\n}\n\nvoid loop() {\n for (count=0;count<6;count++) {\n digitalWrite(pinArray[count], HIGH);\n delay(timer);\n digitalWrite(pinArray[count], LOW);\n delay(timer);\n }\n for (count=5;count>=0;count--) {\n digitalWrite(pinArray[count], HIGH);\n delay(timer);\n digitalWrite(pinArray[count], LOW);\n delay(timer);\n }\n}]]></string>
    <string name="led10_text_view">int LED1Pin = 1;\n int LED2Pin = 2;\n int LED3Pin = 3;\n int LED4Pin = 4;\n int LED5Pin = 5;\n int LED6Pin = 6;\n int LED7Pin = 7;\n void setup() {\n pinMode(LED1Pin, OUTPUT);\n pinMode(LED2Pin, OUTPUT);\n pinMode(LED3Pin, OUTPUT);\n pinMode(LED4Pin, OUTPUT);\n pinMode(LED5Pin, OUTPUT);\n pinMode(LED6Pin, OUTPUT);\n pinMode(LED7Pin, OUTPUT);\n pinMode(A0, INPUT);\n digitalWrite (A0, HIGH);\n }\nvoid loop() {\n if (digitalRead(A0) == LOW){ \ndigitalWrite (LED1Pin, HIGH);\n digitalWrite (LED2Pin, LOW);\n }\n delay(50);\n if (digitalRead(A0) == LOW){\n digitalWrite (LED2Pin, HIGH);\n digitalWrite (LED1Pin, LOW);\n }\n delay(50); }</string>
    <string name="title_activity_aboutus">Aboutus</string>
    <string name="cherala_apps_nemail_apps_cherala_gmail_com">Cherala Apps \n EMAIL : apps.cherala@gmail.com</string>
    <string name="led1">Blink an LED</string>
    <string name="slash">/</string>
    <string name="totalLED_lessonnumber">5</string>
    <string name="totalBasic_lessonnumber">5</string>
    <string name="totalSensor_lessonnumber">5</string>
    <string name="totalMovement_lessonnumber">5</string>
    <string name="default_question_number">3</string>
    <string name="lesson1">1</string>
    <string name="lesson2">2</string>
    <string name="lesson3">3</string>
    <string name="_4">4</string>
    <string name="about_us">About Us</string>
    <string name="more_apps">More Apps</string>
    <string name="sign_out">Sign Out</string>
    <string name="basic_sensors">Basic Sensors</string>
    <string name="communicate">Communicate</string>
    <string name="invite_friends">Invite Friends</string>
    <string name="AppDescription">The App is for Educational Purpose and consisting of basic led projects, sensors and movement using arduino</string>
    <string name="developed_and_designed_by_n_cherala_vivek">DEVELOPED AND DESIGNED BY:  Cherala Vivek</string>
    <string name="totalmovement_lessonnumber">5</string>

    <!-- TODO: Remove or change this placeholder text -->
    <string name="hello_blank_fragment">Hello blank fragment</string>
    <string name="title_activity_lesson1_content">Lesson1Content</string>
    <string name="large_text">
        "Material is the metaphor.\n\n"

        "A material metaphor is the unifying theory of a rationalized space and a system of motion."
        "The material is grounded in tactile reality, inspired by the study of paper and ink, yet "
        "technologically advanced and open to imagination and magic.\n"
        "Surfaces and edges of the material provide visual cues that are grounded in reality. The "
        "use of familiar tactile attributes helps users quickly understand affordances. Yet the "
        "flexibility of the material creates new affordances that supercede those in the physical "
        "world, without breaking the rules of physics.\n"
        "The fundamentals of light, surface, and movement are key to conveying how objects move, "
        "interact, and exist in space and in relation to each other. Realistic lighting shows "
        "seams, divides space, and indicates moving parts.\n\n"

        "Bold, graphic, intentional.\n\n"

        "The foundational elements of print based design typography, grids, space, scale, color, "
        "and use of imagery guide visual treatments. These elements do far more than please the "
        "eye. They create hierarchy, meaning, and focus. Deliberate color choices, edge to edge "
        "imagery, large scale typography, and intentional white space create a bold and graphic "
        "interface that immerse the user in the experience.\n"
        "An emphasis on user actions makes core functionality immediately apparent and provides "
        "waypoints for the user.\n\n"

        "Motion provides meaning.\n\n"

        "Motion respects and reinforces the user as the prime mover. Primary user actions are "
        "inflection points that initiate motion, transforming the whole design.\n"
        "All action takes place in a single environment. Objects are presented to the user without "
        "breaking the continuity of experience even as they transform and reorganize.\n"
        "Motion is meaningful and appropriate, serving to focus attention and maintain continuity. "
        "Feedback is subtle yet clear. Transitions are efﬁcient yet coherent.\n\n"

        "3D world.\n\n"

        "The material environment is a 3D space, which means all objects have x, y, and z "
        "dimensions. The z-axis is perpendicularly aligned to the plane of the display, with the "
        "positive z-axis extending towards the viewer. Every sheet of material occupies a single "
        "position along the z-axis and has a standard 1dp thickness.\n"
        "On the web, the z-axis is used for layering and not for perspective. The 3D world is "
        "emulated by manipulating the y-axis.\n\n"

        "Light and shadow.\n\n"

        "Within the material environment, virtual lights illuminate the scene. Key lights create "
        "directional shadows, while ambient light creates soft shadows from all angles.\n"
        "Shadows in the material environment are cast by these two light sources. In Android "
        "development, shadows occur when light sources are blocked by sheets of material at "
        "various positions along the z-axis. On the web, shadows are depicted by manipulating the "
        "y-axis only. The following example shows the card with a height of 6dp.\n\n"

        "Resting elevation.\n\n"

        "All material objects, regardless of size, have a resting elevation, or default elevation "
        "that does not change. If an object changes elevation, it should return to its resting "
        "elevation as soon as possible.\n\n"

        "Component elevations.\n\n"

        "The resting elevation for a component type is consistent across apps (e.g., FAB elevation "
        "does not vary from 6dp in one app to 16dp in another app).\n"
        "Components may have different resting elevations across platforms, depending on the depth "
        "of the environment (e.g., TV has a greater depth than mobile or desktop).\n\n"

        "Responsive elevation and dynamic elevation offsets.\n\n"

        "Some component types have responsive elevation, meaning they change elevation in response "
        "to user input (e.g., normal, focused, and pressed) or system events. These elevation "
        "changes are consistently implemented using dynamic elevation offsets.\n"
        "Dynamic elevation offsets are the goal elevation that a component moves towards, relative "
        "to the component’s resting state. They ensure that elevation changes are consistent "
        "across actions and component types. For example, all components that lift on press have "
        "the same elevation change relative to their resting elevation.\n"
        "Once the input event is completed or cancelled, the component will return to its resting "
        "elevation.\n\n"

        "Avoiding elevation interference.\n\n"

        "Components with responsive elevations may encounter other components as they move between "
        "their resting elevations and dynamic elevation offsets. Because material cannot pass "
        "through other material, components avoid interfering with one another any number of ways, "
        "whether on a per component basis or using the entire app layout.\n"
        "On a component level, components can move or be removed before they cause interference. "
        "For example, a floating action button (FAB) can disappear or move off screen before a "
        "user picks up a card, or it can move if a snackbar appears.\n"
        "On the layout level, design your app layout to minimize opportunities for interference. "
        "For example, position the FAB to one side of stream of a cards so the FAB won’t interfere "
        "when a user tries to pick up one of cards.\n\n"
    </string>
    <string name="something_here">Something here</string>
    <string name="block_diagram">Block Diagram</string>
    <string name="description">Description</string>
    <string name="title_activity_lesson1_quiz">Lesson1Quiz</string>
    <string name="title_activity_lesson2_content">Lesson2Content</string>
    <string name="title_activity_lesson2_quiz">Lesson2Quiz</string>
</resources>
